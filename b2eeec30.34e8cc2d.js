(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{101:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return a})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return l}));var o=n(3),r=n(7),i=(n(0),n(116)),s={id:"tdd",title:"Good TDD Principles"},a={unversionedId:"tdd",id:"tdd",isDocsHomePage:!1,title:"Good TDD Principles",description:"Purpose",source:"@site/docs/tdd.md",slug:"/tdd",permalink:"/API-Playbook/tdd",editUrl:"https://github.com/LBHackney-IT/API-Playbook/edit/master/docs/tdd.md",version:"current",sidebar:"docs",previous:{title:"Clean Architecture",permalink:"/API-Playbook/clean_architecture"},next:{title:"Writing Unit Tests",permalink:"/API-Playbook/unit_test"}},u=[{value:"Purpose",id:"purpose",children:[]},{value:"Introduction",id:"introduction",children:[]},{value:"TDD Principles",id:"tdd-principles",children:[]},{value:"Test Setup",id:"test-setup",children:[]},{value:"Test Naming",id:"test-naming",children:[]},{value:"Red-Green-Refactor-Commit",id:"red-green-refactor-commit",children:[]},{value:"End-to-end Tests",id:"end-to-end-tests",children:[]},{value:"Test Coverage",id:"test-coverage",children:[]},{value:"When should you fake it?",id:"when-should-you-fake-it",children:[]}],d={toc:u};function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"purpose"},"Purpose"),Object(i.b)("p",null,"The purpose of this section is to provide some general guidelines on how we conduct testing in our applications.  This will give our developers some baseline standards on how to go about testing.  These guidelines are not intended to be prescriptive on what developers should test but to ensure that with a consistent understanding of our tests, it will be easy to grasp by other developers."),Object(i.b)("h2",{id:"introduction"},"Introduction"),Object(i.b)("p",null,"Hackney\u2019s development standards have evolved over the past couple of years and one of the underpinning principles of this evolution is the adoption of test driven development (TDD) where developers are encouraged to start implementing a solution by first writing tests.  These tests should describe the feature being implemented and should steer the implementation as it develops.  The tests should let developers know what a unit or module is expected to do and should provide feedback on whether or not what was required has been achieved.  It is also useful to have these tests in place as a means of regression testing.  As your implementation grows it becomes more and more difficult to determine if any previous code gets broken by newer functionality.  With proper test coverage, regression testing is included by default."),Object(i.b)("h2",{id:"tdd-principles"},"TDD Principles"),Object(i.b)("p",null,"The following are some of the principles we have adopted as part of our TDD principles.  These are meant to be used as guidelines for testing your application:"),Object(i.b)("h2",{id:"test-setup"},"Test Setup"),Object(i.b)("p",null,"Always`` follow the triple \u2018A\u2019 structure - Arrange, Act, Assert ","[AAAs]","\nWhat we should be testing for"),Object(i.b)("h2",{id:"test-naming"},"Test Naming"),Object(i.b)("p",null,"Tests should be clearly named - ideally the name of the test should describe the implementation you are trying to deliver.  For example\npublic void Test1() - Not good\npublic void GetResidentWithValidIdReturnsCorrectRecord() - Better\nUnit Tests\nUnit tests should provide good coverage of the various scenarios that may be encountered; from the main success scenario to any exceptionals or edge cases."),Object(i.b)("h2",{id:"red-green-refactor-commit"},"Red-Green-Refactor-Commit"),Object(i.b)("p",null,"Red\nWrite the unit test as the basic function you want the code to fulfil which will fail\nWrite only as much code as is required to resolve the current error\nEG: Our first test states that a specific method will return a specific value. At the start of development, this method will not exist, so the test will fail, as the error states that the method does not exist, create that method, but have it return null\nGreen\nWrite the minimum code required to get a test to pass\nEG: If our test states that our method will return a specific value, we write the code to provide that value only. We could then write more complex tests to develop greater complexity\nWhen the tests pass, refactor to simplify the code\nWhen using the same variable value multiple times, extract it to SetUp\nCommit\nSave it to github"),Object(i.b)("h2",{id:"end-to-end-tests"},"End-to-end Tests"),Object(i.b)("p",null,"There should be end-to-end tests to test each feature you are implementing.  You can have good coverage of unit tests any they may all pass, but they can easily overlook issues with how each unit interacts with others.  End-to-end tests can pick up on these types of issues.\nEnd-to-end tests can test and validate that a feature is implemented as per user need.\nEnd-to-end tests are also good for regression testing; ensuring that each new implementation doesn\u2019t break the behaviour of the feature as a whole."),Object(i.b)("h2",{id:"test-coverage"},"Test Coverage"),Object(i.b)("p",null,"Test coverage is all about ensuring that your implementation is sufficiently tested.  It is a method of quality checking the tests in our code, ensuring that it covers all possible scenarios and outcomes that your piece of code is expected to capture.\nTest coverage is used as a metric to specify how much of our code needs to be covered by tests.  This will also encourage sufficient refactoring of code so that larger implementations can be broken down into smaller testable chunks.\n","[We need to determine what our test coverage standards should be]"),Object(i.b)("h2",{id:"when-should-you-fake-it"},"When should you fake it?"),Object(i.b)("p",null,"We use a number of different tools to \u2018fake\u2019 or simulate the output of dependent modules not directly tested.  Modules such as Fakr, Moq, Bogus, etc are used across our development.  There is no specific requirement for any one of these to be used.  However, when used, they should be used in an appropriate manner.  The following are some guidelines on when you should fake an implementation.\nWhen to fake it:\nWhen a unit being tested has a dependency on another unit whose output is not directly part of a test, the dependency\u2019s output can be faked.  For example if you are testing a unit that call another unit for data and you are not directly testing the data that gets returned, only what the unit does with the data.  The unit that returns the data can be faked.\nWhen not to fake it:\nIf you are testing a piece of code\u2019s output you will not fake the output you expect from the unit as you will not be able to get a useful test outcome.  For example,  in the following test:\n","[add example test]","\nif your unit accepts two numbers (2 and 2) and you are testing that it returns 4.  You will not create a fake output of \u20184\u2019 in our implementation and test that your unit returns \u20184\u2019"))}l.isMDXComponent=!0},116:function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return f}));var o=n(0),r=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=r.a.createContext({}),l=function(e){var t=r.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=l(e.components);return r.a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=u(e,["components","mdxType","originalType","parentName"]),c=l(n),h=o,f=c["".concat(s,".").concat(h)]||c[h]||p[h]||i;return n?r.a.createElement(f,a(a({ref:t},d),{},{components:n})):r.a.createElement(f,a({ref:t},d))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=h;var a={};for(var u in t)hasOwnProperty.call(t,u)&&(a[u]=t[u]);a.originalType=e,a.mdxType="string"==typeof e?e:o,s[1]=a;for(var d=2;d<i;d++)s[d]=n[d];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);